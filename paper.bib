@misc{2025FalkorDBGraphDatabase,
    title = {{{FalkorDB Graph Database}} with {{GraphRAG}} for {{AI}}/{{ML}} and
             {{GenAI}}},
    year = {2025},
    month = jan,
    urldate = {2025-05-10},
    abstract = {FalkorDB is a graph database optimized for GraphRAG, delivering
                accurate, relevant AI/ML results with reduced hallucinations and
                enhanced performance.},
    langid = {american},
    file = {/home/calle/Zotero/storage/YMIIQPQZ/www.falkordb.com.html},
}

@misc{2025KuzuGraphDatabase,
    title = {Kuzu - {{Graph Database}}},
    year = {2025},
    month = apr,
    journal = {Kuzu},
    urldate = {2025-04-30},
    abstract = {Documentation for Kuzu, an open source, embedded graph database},
    howpublished = {https://docs.kuzudb.com},
    langid = {english},
}

@misc{2025Neo4jGraphDatabase,
    title = {Neo4j {{Graph Database}} \& {{Analytics}} -- {{The Leader}} in {{
             Graph Databases}}},
    year = {2025},
    month = may,
    journal = {Graph Database \& Analytics},
    urldate = {2025-05-10},
    abstract = {Connect data as it's stored with Neo4j. Perform powerful,
                complex queries at scale and speed with our graph data platform.},
    howpublished = {https://neo4j.com/},
    langid = {english},
    file = {/home/calle/Zotero/storage/T99KT7IK/neo4j.com.html},
}

@article{abreuChoosingGraphDatabases,
    title = {Choosing {{Between Graph Databases}} and {{RDF Engines}} for {{
             Consuming}} and {{Mining Linked Data}}},
    author = {Abreu, Domingo De and Flores, Alejandro and Palma, Guillermo and
              Pestana, Valeria and Queipo, Jonathan and Sanchez, Jose and Vidal,
              Maria-Esther},
    abstract = {Graphs naturally represent Linked Data and implementations of
                graph-based tasks are required not only for data consumption, but
                also for mining patterns among links. Despite efficient
                graph-based algorithms and engines have been implemented, there
                is no clear understanding of how these solutions may behave on
                Linked Data. We evaluate both general purpose graph database and
                state-of-the-art RDF engines, and our experimental results reveal
                characteristics of linked datasets and graph-based tasks that may
                affect their performance. These results can be considered as a
                further step for solving the problem of choosing between graph
                databases to consume and mine Linked Data.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/TWK4RWI9/Abreu_Flores_Choosing_Between_Graph_Da.pdf
            },
}

@misc{admin2018NoSQLPerformanceBenchmark,
    title = {{{NoSQL Performance Benchmark}} 2018 -- {{MongoDB}}, {{PostgreSQL}}
             , {{OrientDB}}, {{Neo4j}} and {{ArangoDB}}},
    author = {{admin}},
    year = {2018},
    month = feb,
    journal = {ArangoDB},
    urldate = {2025-05-11},
    abstract = {This article is part of ArangoDB's open-source performance
                benchmark series. This time we included MongoDB, PostgreSQL,
                OrienDB and Neo4j.},
    langid = {american},
    file = {
            /home/calle/Zotero/storage/7KD84WP6/nosql-performance-benchmark-2018-mongodb-postgresql-orientdb-neo4j-arangodb.html
            },
}

@misc{ali2021SurveyRDFStores,
    title = {A {{Survey}} of {{RDF Stores}} \& {{SPARQL Engines}} for {{Querying
             Knowledge Graphs}}},
    author = {Ali, Waqas and Saleem, Muhammad and Yao, Bin and Hogan, Aidan and
              Ngomo, Axel-Cyrille Ngonga},
    year = {2021},
    month = oct,
    number = {arXiv:2102.13027},
    eprint = {2102.13027},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2102.13027},
    urldate = {2025-04-30},
    abstract = {RDF has seen increased adoption in recent years, prompting the
                standardization of the SPARQL query language for RDF, and the
                development of local and distributed engines for processing
                SPARQL queries. This survey paper provides a comprehensive review
                of techniques and systems for querying RDF knowledge graphs.
                While other reviews on this topic tend to focus on the
                distributed setting, the main focus of the work is on providing a
                comprehensive survey of state-of-the-art storage, indexing and
                query processing techniques for efficiently evaluating SPARQL
                queries in a local setting (on one machine). To keep the survey
                selfcontained, we also provide a short discussion on graph
                partitioning techniques used in the distributed setting. We
                conclude by discussing contemporary research challenges for
                further improving SPARQL query engines. This extended version
                also provides a survey of over one hundred SPARQL query engines
                and the techniques they use, along with twelve benchmarks and
                their features.},
    archiveprefix = {arXiv},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/LZ5R9A68/Ali_Saleem_2021_A_Survey_of_RDF_Stores_&.pdf
            },
}

@article{angles2008SurveyGraphDatabase,
    title = {Survey of Graph Database Models},
    author = {Angles, Renzo and Gutierrez, Claudio},
    year = {2008},
    month = feb,
    journal = {ACM Comput. Surv.},
    volume = {40},
    number = {1},
    pages = {1--39},
    issn = {0360-0300, 1557-7341},
    doi = {10.1145/1322432.1322433},
    urldate = {2025-04-23},
    abstract = {Graph database models can be defined as those in which data
                structures for the schema and instances are modeled as graphs or
                generalizations of them, and data manipulation is expressed by
                graph-oriented operations and type constructors. These models
                took off in the eighties and early nineties alongside
                object-oriented models. Their influence gradually died out with
                the emergence of other database models, in particular
                geographical, spatial, semistructured, and XML. Recently, the
                need to manage information with graph-like nature has
                reestablished the relevance of this area. The main objective of
                this survey is to present the work that has been conducted in the
                area of graph database modeling, concentrating on data structures
                , query languages, and integrity constraints.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/6VSZA4VV/Angles_Gutierrez_2008_Survey_of_graph_database.pdf
            },
}

@article{angles2018FoundationsModernQuery,
    title = {Foundations of {{Modern Query Languages}} for {{Graph Databases}}},
    author = {Angles, Renzo and Arenas, Marcelo and Barcel{\'o}, Pablo and Hogan
              , Aidan and Reutter, Juan and Vrgo{\v c}, Domagoj},
    year = {2018},
    month = sep,
    journal = {ACM Comput. Surv.},
    volume = {50},
    number = {5},
    pages = {1--40},
    issn = {0360-0300, 1557-7341},
    doi = {10.1145/3104031},
    urldate = {2025-04-23},
    abstract = {We survey foundational features underlying modern graph query
                languages. We first discuss two popular graph data models:
                edge-labelled graphs , where nodes are connected by directed,
                labelled edges, and property graphs , where nodes and edges can
                further have attributes. Next we discuss the two most fundamental
                graph querying functionalities: graph patterns and navigational
                expressions . We start with graph patterns, in which a
                graph-structured query is matched against the data. Thereafter,
                we discuss navigational expressions, in which patterns can be
                matched recursively against the graph to navigate paths of
                arbitrary length; we give an overview of what kinds of
                expressions have been proposed and how they can be combined with
                graph patterns. We also discuss several semantics under which
                queries using the previous features can be evaluated, what
                effects the selection of features and semantics has on complexity
                , and offer examples of such features in three modern languages
                that are used to query graphs: SPARQL, Cypher, and Gremlin. We
                conclude by discussing the importance of formalisation for graph
                query languages; a summary of what is known about SPARQL, Cypher,
                and Gremlin in terms of expressivity and complexity; and an
                outline of possible future directions for the area.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/VAK32Y7P/Angles_Arenas_2018_Foundations_of_Modern_Que.pdf
            },
}

@misc{ApacheTinkerPopGremlin,
    title = {Apache {{TinkerPop}}: {{Gremlin}}},
    urldate = {2025-04-29},
    howpublished = {https://tinkerpop.apache.org/gremlin.html},
    file = {/home/calle/Zotero/storage/YHWDGA2F/gremlin.html},
}

@article{barghiBitGraphFrameworkScaling,
    title = {{{BitGraph}}: {{A Framework For Scaling Temporal Graph Queries}} on
             {{GPUs}}},
    author = {Barghi, Alexandria},
    abstract = {Graph query languages have become the standard among data
                scientists analyzing large, dynamic graphs, allowing them to
                structure their analysis as SQL-like queries. One of the
                challenges in supporting graph query languages is that, unlike
                SQL queries, graph queries nearly always involve aggregation of
                sparse data, making it challenging to scale graph queries without
                heavy reliance on expensive indices. This paper introduces the
                first major release of BitGraph, a graph query processing engine
                that uses GPU-acceleration to quickly process Gremlin graph
                queries with minimal memory overhead, along with its supporting
                stack, Gremlin++, which provides query language support in C++,
                and Maelstrom, a lightweight library for compute-agnostic,
                accelerated vector operations built on top of Thrust. This paper
                also analyzes the performance of BitGraph compared to existing
                CPU-only backends applied specifically to temporal graph queries,
                demonstrating BitGraph's superior scalability and speedup of up
                to 35x over naive CPU implementations.},
    langid = {english},
    keywords = {Done},
    file = {
            /home/calle/Zotero/storage/KJPMTWAK/Barghi_BitGraph_A_Framework_For.pdf
            },
}

@article{besta2019GraphProcessingFPGAs,
    title = {Graph {{Processing}} on {{FPGAs}}: {{Taxonomy}}, {{Survey}}, {{
             Challenges}}},
    author = {Besta, Maciej and Stanojevic, Dimitri},
    year = {2019},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/TL8ECPLT/Besta_Stanojevic_Graph_Processing_on_FPGAs.pdf
            },
}

@inproceedings{buluc2017DesignGraphBLASAPI,
    title = {Design of the {{GraphBLAS API}} for {{C}}},
    booktitle = {2017 {{IEEE International Parallel}} and {{Distributed
                 Processing Symposium Workshops}} ({{IPDPSW}})},
    author = {Buluc, Aydin and Mattson, Tim and McMillan, Scott and Moreira,
              Jose and Yang, Carl},
    year = {2017},
    month = may,
    pages = {643--652},
    publisher = {IEEE},
    address = {Orlando / Buena Vista, FL, USA},
    doi = {10.1109/IPDPSW.2017.117},
    urldate = {2025-05-11},
    abstract = {The purpose of the GraphBLAS Forum is to standardize
                linear-algebraic building blocks for graph computations. An
                important part of this standardization effort is to translate the
                mathematical specification into an actual Application Programming
                Interface (API) that (i) is faithful to the mathematics and (ii)
                enables efficient implementations on modern hardware. This paper
                documents the approach taken by the C language specification
                subcommittee and presents the main concepts, constructs, and
                objects within the GraphBLAS API. Use of the API is illustrated
                by showing an implementation of the betweenness centrality
                algorithm.},
    isbn = {978-1-5386-3408-0},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/U4NHY8BW/Buluc_Mattson_2017_Design_of_the_GraphBLAS_A.pdf
            },
}

@inproceedings{cailliau2019RedisGraphGraphBLASEnabled,
    title = {{{RedisGraph GraphBLAS Enabled Graph Database}}},
    booktitle = {2019 {{IEEE International Parallel}} and {{Distributed
                 Processing Symposium Workshops}} ({{IPDPSW}})},
    author = {Cailliau, Pieter and Davis, Tim and Gadepally, Vijay and Kepner,
              Jeremy and Lipman, Roi and Lovitz, Jeffrey and Ouaknine, Keren},
    year = {2019},
    month = may,
    pages = {285--286},
    publisher = {IEEE},
    address = {Rio de Janeiro, Brazil},
    doi = {10.1109/IPDPSW.2019.00054},
    urldate = {2025-04-30},
    abstract = {RedisGraph is a Redis module developed by Redis Labs to add
                graph database functionality to the Redis database. RedisGraph
                represents connected data as adjacency matrices. By representing
                the data as sparse matrices and employing the power of GraphBLAS
                (a highly optimized library for sparse matrix operations),
                RedisGraph delivers a fast and efficient way to store, manage and
                process graphs. Initial benchmarks indicate that RedisGraph is
                significantly faster than comparable graph databases.},
    copyright = {
                 https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html
                 },
    isbn = {978-1-7281-3510-6},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/DSUGYZGE/Cailliau_Davis_2019_RedisGraph_GraphBLAS_Enab.pdf
            },
}

@inproceedings{chawla2017ShortestPathApproach,
    title = {A Shortest Path Approach to {{SPARQL}} Chain Query Optimisation},
    booktitle = {2017 {{International Conference}} on {{Advances}} in {{
                 Computing}}, {{Communications}} and {{Informatics}} ({{ICACCI}})
                 },
    author = {Chawla, Tanvi and Singh, Girdhari and Pilli, Emmanuel S.},
    year = {2017},
    month = sep,
    pages = {1778--1778},
    publisher = {IEEE},
    address = {Udupi},
    doi = {10.1109/ICACCI.2017.8126102},
    urldate = {2025-04-30},
    isbn = {978-1-5090-6367-3},
}

@article{chen2019GrasperHighPerformance,
    title = {Grasper: {{A High Performance Distributed System}} for {{OLAP}} on
             {{Property Graphs}}},
    author = {Chen, Hongzhi and Li, Changji and Fang, Juncheng and Huang,
              Chenghuan and Cheng, James and Zhang, Jian and Hou, Yifan and Yan,
              Xiao},
    year = {2019},
    abstract = {The property graph (PG) model is one of the most general graph
                data model and has been widely adopted in many graph analytics
                and processing systems. However, existing systems suffer from
                poor performance in terms of both latency and throughput for
                processing online analytical workloads on PGs due to their design
                defects such as expensive interactions with external databases,
                low parallelism, and high network overheads. In this paper, we
                propose Grasper, a high performance distributed system for OLAP
                on property graphs. Grasper adopts RDMA-aware system designs to
                reduce the network communication cost. We propose a novel query
                execution model, called Expert Model, which supports adaptive
                parallelism control at the fine-grained query operation level and
                allows tailored optimizations for different categories of query
                operators, thus achieving high parallelism and good load
                balancing. Experimental results show that Grasper achieves low
                latency and high throughput on a broad range of online analytical
                workloads.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/9CYVWE96/Chen_Li_2019_Grasper_A_High_Performan.pdf
            },
}

@misc{chen2021GTranMakingDistributed,
    title = {G-{{Tran}}: {{Making Distributed Graph Transactions Fast}}},
    shorttitle = {G-{{Tran}}},
    author = {Chen, Hongzhi and Li, Changji and Zheng, Chenguang and Huang,
              Chenghuan and Fang, Juncheng and Cheng, James and Zhang, Jian},
    year = {2021},
    month = may,
    number = {arXiv:2105.04449},
    eprint = {2105.04449},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2105.04449},
    urldate = {2025-04-30},
    abstract = {Graph transaction processing raises many unique challenges such
                as random data access due to the irregularity of graph structures
                , low throughput and high abort rate due to the relatively large
                read/write sets in graph transactions. To address these
                challenges, we present G-Tran --- an RDMA-enabled distributed
                in-memory graph database with serializable and snapshot isolation
                support. First, we propose a graph-native data store to achieve
                good data locality and fast data access for transactional updates
                and queries. Second, G-Tran adopts a fully decentralized
                architecture that leverages RDMA to process distributed
                transactions with the MPP model, which can achieve high
                performance by utilizing all computing resources. In addition, we
                propose a new MV-OCC implementation with two optimizations to
                address the issue of large read/write sets in graph transactions.
                Extensive experiments show that G-Tran achieves competitive
                performance compared with other popular graph databases on
                benchmark workloads.},
    archiveprefix = {arXiv},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/VN7HG5MI/Chen_Li_2021_G_Tran_Making_Distribute.pdf
            },
}

@article{chen2022ThunderGPResourceEfficientGraph,
    title = {{{ThunderGP}}: {{Resource-Efficient Graph Processing Framework}} on
             {{FPGAs}} with {{HLS}}},
    shorttitle = {{{ThunderGP}}},
    author = {Chen, Xinyu and Cheng, Feng and Tan, Hongshi and Chen, Yao and He,
              Bingsheng and Wong, Weng-Fai and Chen, Deming},
    year = {2022},
    month = dec,
    journal = {ACM Trans. Reconfigurable Technol. Syst.},
    volume = {15},
    number = {4},
    pages = {1--31},
    issn = {1936-7406, 1936-7414},
    doi = {10.1145/3517141},
    urldate = {2025-05-11},
    abstract = {FPGA has been an emerging computing infrastructure in
                datacenters benefiting from fine-grained parallelism, energy
                efficiency, and reconfigurability. Meanwhile, graph processing
                has attracted tremendous interest in data analytics, and its
                performance is in increasing demand with the rapid growth of
                data. Many works have been proposed to tackle the challenges of
                designing efficient FPGA-based accelerators for graph processing.
                However, the largely overlooked programmability still requires
                hardware design expertise and sizable development efforts from
                developers. ThunderGP , a high-level synthesis based graph
                processing framework on FPGAs, is hence proposed to close the gap
                , with which developers could enjoy high performance of
                FPGA-accelerated graph processing by writing only a few
                high-level functions with no knowledge of the hardware. ThunderGP
                adopts the gather-apply-scatter model as the abstraction of
                various graph algorithms and realizes the model by a built-in
                highly parallel and memory-efficient accelerator template. With
                high-level functions as inputs, ThunderGP automatically explores
                massive resources of multiple super-logic regions of modern FPGA
                platforms to generate and deploy accelerators, as well as
                schedule tasks for them. Although ThunderGP on DRAM-based
                platforms is memory bandwidth bounded, recent high bandwidth
                memory (HBM) brings large potentials to performance. However, the
                system bottleneck shifts from memory bandwidth to resource
                consumption on HBM-enabled platforms. Therefore, we further
                propose to improve resource efficiency of ThunderGP to utilize
                more memory bandwidth from HBM. We conduct evaluation with seven
                common graph applications and 19 graphs. ThunderGP on DRAM-based
                hardware platforms provides 1.9{\texttimes} {$\sim$} 5.2{
                \texttimes} improvement on bandwidth efficiency over the state of
                the art, whereas ThunderGP on HBM-based hardware platforms
                delivers up to 5.2{\texttimes} speedup over the state-of-the-art
                RTL-based approach. This work is open sourced on GitHub at~
                https://github.com/Xtra-Computing/ThunderGP .},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/VNQGRXNH/Chen_Cheng_2022_ThunderGP_Resource_Effic.pdf
            },
}

@article{chenAccurateSummarybasedCardinality2022,
    title = {Accurate Summary-Based Cardinality Estimation through the Lens of
             Cardinality Estimation Graphs},
    author = {Chen, Jeremy and Huang, Yuqing and Wang, Mushi and Salihoglu,
              Semih and Salem, Ken},
    year = {2022},
    month = apr,
    journal = {Proc. VLDB Endow.},
    volume = {15},
    number = {8},
    pages = {1533--1545},
    issn = {2150-8097},
    doi = {10.14778/3529337.3529339},
    urldate = {2024-11-18},
    abstract = {This paper is an experimental and analytical study of two
                classes of summary-based cardinality estimators that use
                statistics about input relations and small-size joins in the
                context of graph database management systems: (i) optimistic
                estimators that make uniformity and conditional independence
                assumptions; and (ii) the recent pessimistic estimators that use
                information theoretic linear programs (LPs). We begin by
                analyzing how optimistic estimators use pre-computed statistics
                to generate cardinality estimates. We show these estimators can
                be modeled as picking bottom-to-top paths in a cardinality
                estimation graph (CEG), which contains subqueries as nodes and
                edges whose weights are average degree statistics. We show that
                existing optimistic estimators have either undefined or fixed
                choices for picking CEG paths as their estimates and ignore
                alternative choices. Instead, we outline a space of optimistic
                estimators to make an estimate on CEGs, which subsumes existing
                estimators. We show, using an extensive empirical analysis, that
                effective paths depend on the structure of the queries. While on
                acyclic queries and queries with small-size cycles, using the
                maximum-weight path is effective to address the well known
                underestimation problem, on queries with larger cycles these
                estimates tend to overestimate, which can be addressed by using
                minimum weight paths. We next show that optimistic estimators and
                seemingly disparate LP-based pessimistic estimators are in fact
                connected. Specifically, we show that CEGs can also model some
                recent pessimistic estimators. This connection allows us to adopt
                an optimization from pessimistic estimators to optimistic ones,
                and provide insights into the pessimistic estimators, such as
                showing that they have combinatorial solutions.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/WQHI9Y8S/Chen_Huang_2022_Accurate_summary_based_ca.pdf
            },
}

@article{dann2023FPGAbasedQueryAcceleration,
    title = {{{FPGA-based Query Acceleration}} for {{Non-Relational Databases}}},
    author = {Dann, Jonas},
    year = {2023},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/88REFDX3/Dann_FPGA_based_Query_Accelera.pdf
            },
}

@misc{dann2024GraphMatchSubgraphQuery,
    title = {{{GraphMatch}}: {{Subgraph Query Processing}} on {{FPGAs}}},
    shorttitle = {{{GraphMatch}}},
    author = {Dann, Jonas and G{\"o}tz, Tobias and Ritter, Daniel and Giceva,
              Jana and Fr{\"o}ning, Holger},
    year = {2024},
    month = feb,
    number = {arXiv:2402.17559},
    eprint = {2402.17559},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2402.17559},
    urldate = {2025-05-11},
    abstract = {Efficiently finding subgraph embeddings in large graphs is
                crucial for many application areas like biology and social
                network analysis. Set intersections are the predominant and most
                challenging aspect of current join-based subgraph query
                processing systems for CPUs. Previous work has shown the
                viability of utilizing FPGAs for acceleration of graph and join
                processing.},
    archiveprefix = {arXiv},
    langid = {english},
    keywords = {Computer Science - Databases,Computer Science - Hardware
                Architecture},
    file = {
            /home/calle/Zotero/storage/3NNN3QJE/Dann_Götz_2024_GraphMatch_Subgraph_Quer.pdf
            },
}

@article{dann2024GraphScaleScalableProcessing,
    title = {{{GraphScale}}: {{Scalable Processing}} on {{FPGAs}} for {{HBM}}
             and {{Large Graphs}}},
    shorttitle = {{{GraphScale}}},
    author = {Dann, Jonas and Ritter, Daniel and Fr{\"o}ning, Holger},
    year = {2024},
    month = jun,
    journal = {ACM Trans. Reconfigurable Technol. Syst.},
    volume = {17},
    number = {2},
    pages = {1--23},
    issn = {1936-7406, 1936-7414},
    doi = {10.1145/3616497},
    urldate = {2025-05-11},
    abstract = {Recent advances in graph processing on FPGAs promise to
                alleviate performance bottlenecks with irregular memory access
                patterns. Such bottlenecks challenge performance for a growing
                number of important application areas like machine learning and
                data analytics. While FPGAs denote a promising solution through
                flexible memory hierarchies and massive parallelism, we argue
                that current graph processing accelerators either use the
                off-chip memory bandwidth inefficiently or do not scale well
                across memory channels. In this work, we propose GraphScale, a
                scalable graph processing framework for FPGAs. GraphScale
                combines multi-channel memory with asynchronous graph processing
                (i.e., for fast convergence on results) and a compressed graph
                representation (i.e., for efficient usage of memory bandwidth and
                reduced memory footprint). GraphScale solves common graph
                problems like breadth-first search, PageRank, and weakly
                connected components through modular user-defined functions, a
                novel two-dimensional partitioning scheme, and a high-performance
                two-level crossbar design. Additionally, we extend GraphScale to
                scale to modern high-bandwidth memory (HBM) and reduce
                partitioning overhead of large graphs with binary packing.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/USKHIYLE/Dann_Ritter_2024_GraphScale_Scalable_Proc.pdf
            },
}

@article{debrouvier2021ModelQueryLanguage,
    title = {A Model and Query Language for Temporal Graph Databases},
    author = {Debrouvier, Ariel and Parodi, Eliseo and Perazzo, Mat{\'i}as and
              Soliani, Valeria and Vaisman, Alejandro},
    year = {2021},
    month = sep,
    journal = {The VLDB Journal},
    volume = {30},
    number = {5},
    pages = {825--858},
    issn = {1066-8888, 0949-877X},
    doi = {10.1007/s00778-021-00675-4},
    urldate = {2025-04-29},
    abstract = {Graph databases are becoming increasingly popular for modeling
                different kinds of networks for data analysis. They are built
                over the property graph data model, where nodes and edges are
                annotated with property-value pairs. Most existing work in the
                field is based on graphs were the temporal dimension is not
                considered. However, time is present in most real-world problems.
                Many different kinds of changes may occur in a graph as the world
                it represents evolves across time. For instance, edges, nodes,
                and properties can be added and/or deleted, and property values
                can be updated. This paper addresses the problem of modeling,
                storing, and querying temporal property graphs, allowing keeping
                the history of a graph database. This paper introduces a temporal
                graph data model, where nodes and relationships contain
                attributes (properties) timestamped with a validity interval.
                Graphs in this model can be heterogeneous, that is, relationships
                may be of different kinds. Associated with the model, a
                high-level graph query language, denoted T-GQL, is presented,
                together with a collection of algorithms for computing different
                kinds of temporal paths in a graph, capturing different temporal
                path semantics. T-GQL can express queries like ``Give me the
                friends of the friends of Mary, who lived in Brussels at the same
                time than her, and also give me the periods when this happened''.
                As a proof-of-concept, a Neo4j-based implementation of the above
                is also presented, and a client-side interface allows submitting
                queries in T-GQL to a Neo4j server. Finally, experiments were
                carried out over synthetic and real-world data sets, with a
                twofold goal: on the one hand, to show the plausibility of the
                approach; on the other hand, to analyze the factors that affect
                performance, like the length of the paths mentioned in the query,
                and the size of the graph.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/BV8H4TRD/Debrouvier_Parodi_2021_A_model_and_query_languag.pdf
            },
}

@misc{deutsch2019TigerGraphNativeMPP,
    title = {{{TigerGraph}}: {{A Native MPP Graph Database}}},
    shorttitle = {{{TigerGraph}}},
    author = {Deutsch, Alin and Xu, Yu and Wu, Mingxi and Lee, Victor},
    year = {2019},
    month = jan,
    number = {arXiv:1901.08248},
    eprint = {1901.08248},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.1901.08248},
    urldate = {2025-05-11},
    abstract = {We present TigerGraph, a graph database system built from the
                ground up to support massively parallel computation of queries
                and analytics. TigerGraph's high-level query language, GSQL, is
                designed for compatibility with SQL, while simultaneously
                allowing NoSQL programmers to continue thinking in
                Bulk-Synchronous Processing (BSP) terms and reap the benefits of
                high-level specification. GSQL is sufficiently high-level to
                allow declarative SQL-style programming, yet sufficiently
                expressive to concisely specify the sophisticated iterative
                algorithms required by modern graph analytics and traditionally
                coded in general-purpose programming languages like C++ and Java.
                We report very strong scale-up and scale-out performance over a
                benchmark we published on GitHub for full reproducibility.},
    archiveprefix = {arXiv},
    langid = {english},
    keywords = {Computer Science - Databases},
    file = {
            /home/calle/Zotero/storage/PHLL8RGB/Deutsch_Xu_2019_TigerGraph_A_Native_MPP.pdf
            },
}

@inproceedings{deutsch2022GraphPatternMatching,
    title = {Graph {{Pattern Matching}} in {{GQL}} and {{SQL}}/{{PGQ}}},
    booktitle = {Proceedings of the 2022 {{International Conference}} on {{
                 Management}} of {{Data}}},
    author = {Deutsch, Alin and Francis, Nadime and Green, Alastair and Hare,
              Keith and Li, Bei and Libkin, Leonid and Lindaaker, Tobias and
              Marsault, Victor and Martens, Wim and Michels, Jan and Murlak,
              Filip and Plantikow, Stefan and Selmer, Petra and Van Rest, Oskar
              and Voigt, Hannes and Vrgo{\v c}, Domagoj and Wu, Mingxi and Zemke,
              Fred},
    year = {2022},
    month = jun,
    pages = {2246--2258},
    publisher = {ACM},
    address = {Philadelphia PA USA},
    doi = {10.1145/3514221.3526057},
    urldate = {2025-04-22},
    isbn = {978-1-4503-9249-5},
    langid = {english},
    keywords = {Done},
    file = {
            /home/calle/Zotero/storage/A3USQSSW/Deutsch_Francis_2022_Graph_Pattern_Matching_in.pdf
            },
}

@article{donkersLinkedDataSmart,
    title = {Linked {{Data}} for {{Smart Homes}}: {{Comparing RDF}} and {{
             Labeled Property Graphs}}},
    author = {Donkers, Alex Johannes Albertus and Yang, Dujuan and Baken, Nico},
    abstract = {The need to integrate siloed data in the built environment led
                to a gaining interest in semantic web technologies in the
                Architecture, Engineering and Construction (AEC) sector.
                Especially for smart home developments, the integration of
                information about the building, users and Internet of Things
                (IoT) devices could be valuable. The Resource Description
                Framework (RDF) is the standard model for the semantic web,
                however, labeled property graphs (LPG) also proved to be
                effective in linking data. This research used the Open Smart Home
                Dataset and a dataset representing a kitchen to compare the two
                graph models both qualitatively and quantitatively. The
                comparison shows that native labeled property graphs are less
                complex and outperform the atomic RDF in complex graph
                traversals. However, RDF shows qualitative advantages for
                multi-domain and multi-stakeholder environments, such as the use
                of ontologies and HTTP URIs, making it a more stable
                interoperability format.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/6L4P3VIS/Donkers_Yang_Linked_Data_for_Smart_Hom.pdf
            },
}

@article{feng2023KUZUGraphDatabase,
    title = {{{K{\`U}ZU}}{\textasciicircum}* {{Graph Database Management System}
             }},
    author = {Feng, Xiyang and Jin, Guodong and Chen, Ziyi and Liu, Chang and
              Saliho{\u g}lu, Semih},
    year = {2023},
    abstract = {Datasets and workloads of popular applications that use graph
                database management systems (GDBMSs) require a set of storage and
                query processing features that RDBMSs do not traditionally
                optimize for. These include optimizations for: (i) many-to-many
                (m-n) joins; (ii) cyclic joins; (iii) recursive joins; (iv)
                semi-structured data storage; and (v) support for universal
                resource identifiers. We present K{\`u}zu, a new GDBMS we are
                developing at University of Waterloo that aims to integrate
                state-of-art storage, indexing, and query processing techniques
                to highly optimize for this feature set. This paper serves the
                dual role of describing our vision for K{\`u}zu and the system's
                factorized query processor, which is based on two design goals:
                (i) achieving good factorization structures under m-n joins; and
                (ii) ensuring sequential scans that avoid entire scans of columns
                and join indices when possible. As we show these two goals can
                sometimes conflict and we describe our core binary and worst-case
                optimal (multiway) join operators that simultaneously achieve
                both goals. K{\`u}zu is actively being developed to be a fully
                functional open-source DBMS with the goal of wide user adoption.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/INTLKIVW/Feng_Jin_2023_KÙZU^_Graph_Database_Man.pdf
            },
}

@inproceedings{francis2018CypherEvolvingQuery,
    title = {Cypher: {{An Evolving Query Language}} for {{Property Graphs}}},
    shorttitle = {Cypher},
    booktitle = {Proceedings of the 2018 {{International Conference}} on {{
                 Management}} of {{Data}}},
    author = {Francis, Nadime and Green, Alastair and Guagliardo, Paolo and
              Libkin, Leonid and Lindaaker, Tobias and Marsault, Victor and
              Plantikow, Stefan and Rydberg, Mats and Selmer, Petra and Taylor,
              Andr{\'e}s},
    year = {2018},
    month = may,
    pages = {1433--1445},
    publisher = {ACM},
    address = {Houston TX USA},
    doi = {10.1145/3183713.3190657},
    urldate = {2025-04-29},
    abstract = {The Cypher property graph query language is an evolving language
                , originally designed and implemented as part of the Neo4j graph
                database, and it is currently used by several commercial database
                products and researchers. We describe Cypher 9, which is the
                first version of the language governed by the openCypher
                Implementers Group. We first introduce the language by example,
                and describe its uses in industry. We then provide a formal
                semantic definition of the core read-query features of Cypher,
                including its variant of the property graph data model, and its
                ``ASCII Art'' graph pattern matching mechanism for expressing
                subgraphs of interest to an application. We compare the features
                of Cypher to other property graph query languages, and describe
                extensions, at an advanced stage of development, which will form
                part of Cypher 10, turning the language into a compositional
                language which supports graph projections and multiple named
                graphs.},
    isbn = {978-1-4503-4703-7},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/GAEL5YEL/Francis_Green_2018_Cypher_An_Evolving_Query.pdf
            },
}

@article{FutureBigGraphs,
    title = {The Future Is Big Graphs},
    langid = {english},
    file = {/home/calle/Zotero/storage/BVYAUAP7/The_future_is_big_graphs.pdf},
}

@article{gharaibehEfficientLargeScaleGraph,
    title = {Efficient {{Large-Scale Graph Processing}} on {{Hybrid CPU}} and {{
             GPU Systems}}},
    author = {Gharaibeh, Abdullah and {Santos-Neto}, Elizeu and Costa, Lauro and
              Ripeanu, Matei},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/9DMEACYZ/Gharaibeh_Santos-Neto_Efficient_Large_Scale_Gra.pdf
            },
}

@article{goodmanSprinkleSPARQLOptimizing,
    title = {Sprinkle {{SPARQL}}: {{Optimizing Semantic Graph Database Queries}}
             },
    author = {Goodman, Eric L and Jimenez, Edward and Joslyn, Cliff and Haglin,
              David and Adolf, Bob},
    abstract = {We present Sprinkle SPARQL, an algorithm for performing complex
                SPARQL queries in an efficient, scalable, and graph-oriented
                manner on a shared-memory machine. The algorithm has two phases.
                During the first phase, called the Sprinkle phase, each triple
                pattern is processed in isolation. The set of RDF Terms
                satisfying each triple pattern is stored in hash tables for each
                variable. From these constrained sets of RDF Terms, we then
                perform join operations to create the result. The benefits of the
                preliminary Sprinkle phase are two fold: 1) the number of
                variable bindings is significantly reduced, minimizing the size
                and complexity of the expensive join operations, and 2) we obtain
                enough information to select a near optimal execution plan for
                the join phase. We evaluate our approach on two data sets:
                LUBM(8000) and a one billion edge R-MAT graph generated with
                Graph5001 parameters and extended to have edge labels.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/H64VBUU3/Goodman_Jimenez_Sprinkle_SPARQL_Optimizi.pdf
            },
}

@misc{GraphBLAS,
    title = {The {{GraphBLAS}}},
    journal = {Welcome to the GraphBLAS Forum},
    urldate = {2025-05-11},
    abstract = {This site contains information related to the GraphBLAS Graph
                Linear Algebra API.},
    howpublished = {https://graphblas.org/},
    langid = {american},
    file = {/home/calle/Zotero/storage/KI6KYXHZ/graphblas.org.html},
}

@misc{gratzer2025BARQVectorizedSPARQL,
    title = {{{BARQ}}: {{A Vectorized SPARQL Query Execution Engine}}},
    shorttitle = {{{BARQ}}},
    author = {Gr{\"a}tzer, Simon and Heling, Lars and Klinov, Pavel},
    year = {2025},
    month = apr,
    number = {arXiv:2504.04584},
    eprint = {2504.04584},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2504.04584},
    urldate = {2025-04-30},
    abstract = {Stardog is a commercial Knowledge Graph platform built on top of
                an RDF graph database whose primary means of communication is a
                standardized graph query language called SPARQL. This paper
                describes our journey of developing a more performant query
                execution layer and plugging it into Stardog's query engine. The
                new executor, called BARQ, is based on the known principle of
                processing batches of tuples at a time in most critical query
                operators, particularly joins. In addition to presenting BARQ,
                the paper describes the challenges of integrating it into a
                mature, tightly integrated system based on the classical
                tuple-at-a-time Volcano model. It offers a gradual approach to
                overcoming the challenges that small- to medium-size engineering
                teams typically face. Finally, the paper presents experimental
                results showing that BARQ makes Stardog substantially faster on
                CPU-bound queries without sacrificing performance on disk-bound
                and OLTP-style queries.},
    archiveprefix = {arXiv},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/ZMN95XED/Grätzer_Heling_2025_BARQ_A_Vectorized_SPARQL.pdf
            },
}

@article{gupta2024SPARQLOptimizationUsing,
    title = {{{SPARQL Optimization Using Re-ordering Joining Patterns}} with {{
             Surrogate Key Concept}} and {{Subset Patterns}}},
    author = {Gupta, Rupal and Malik, Sanjay Kumar},
    year = {2024},
    month = may,
    journal = {Journal of Web Engineering},
    pages = {393--430},
    issn = {1544-5976},
    doi = {10.13052/jwe1540-9589.2334},
    urldate = {2025-04-30},
    abstract = {Semantic web data resides on the web in the form of knowledge
                graphs known as RDF graphs and searching around the web has been
                always a crucial task. For the data retrieval of RDF data of the
                semantic web, SPARQL query language has been used which in turn
                is based on triple patterns and joins. Optimization of SPARQL
                query has been a problematic concern for decades due to the large
                amount of triple patterns associated with RDF data. Although
                several researchers have put a lot of effort into the
                optimization of SPARQL query, it is difficult to understand the
                concept from scratch due to its diversified nature. This paper
                analyses various optimization techniques for the SPARQL query
                used with the semantic web to process knowledge graphs. These
                techniques include join-based, heuristic-based, rule-based, and
                indexing-based approaches for optimization. This paper will help
                researchers in this domain to easily get into the core concept of
                SPARQL execution along with various optimization approaches used
                for query processing, which can help in various other domains
                like linked open data and information retrieval. In this paper,
                an optimization algorithm HSOA (hybrid SPARQL optimization
                algorithm) has been proposed, which comprises the features of
                index-based, cost-based, and triple reordering-based optimization
                approaches. The proposed hybrid algorithm has been designed
                specifically for n-triple RDF data, which comprises subset
                patterns, and surrogate key concepts. The results produced by the
                proposed algorithm are encouraging and have also been tested and
                compared with the benchmark dataset and SPARQL queries like LUBM,
                BSBM, and SP2Bench.},
    copyright = {Copyright (c) 2024 Journal of Web Engineering},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/G82L4JX8/Gupta_Malik_2024_SPARQL_Optimization_Using.pdf
            },
}

@article{guptaColumnarStorageListbased2021,
    title = {Columnar Storage and List-Based Processing for Graph Database
             Management Systems},
    author = {Gupta, Pranjal and Mhedhbi, Amine and Salihoglu, Semih},
    year = {2021},
    month = jul,
    journal = {Proc. VLDB Endow.},
    volume = {14},
    number = {11},
    pages = {2491--2504},
    issn = {2150-8097},
    doi = {10.14778/3476249.3476297},
    urldate = {2024-11-18},
    abstract = {We revisit column-oriented storage and query processing
                techniques in the context of contemporary graph database
                management systems (GDBMSs). Similar to column-oriented RDBMSs,
                GDBMSs support read-heavy analytical workloads that however have
                fundamentally different data access patterns than traditional
                analytical workloads. We first derive a set of desiderata for
                optimizing storage and query processors of GDBMS based on their
                access patterns. We then present the design of columnar storage,
                compression, and query processing techniques based on these
                desiderata. In addition to showing direct integration of existing
                techniques from columnar RDBMSs, we also propose novel ones that
                are optimized for GDBMSs. These include a novel list-based query
                processor, which avoids expensive data copies of traditional
                block-based processors under many-to-many joins, a new data
                structure we call singleindexed edge property pages and an
                accompanying edge ID scheme, and a new application of Jacobson's
                bit vector index for compressing NULL values and empty lists. We
                integrated our techniques into the GraphflowDB in-memory GDBMS.
                Through extensive experiments, we demonstrate the scalability and
                query performance benefits of our techniques.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/NIWK6PGY/Gupta_Mhedhbi_2021_Columnar_storage_and_list.pdf
            },
}

@misc{he2023GraphScopeFlexLEGOlike,
    title = {{{GraphScope Flex}}: {{LEGO-like Graph Computing Stack}}},
    shorttitle = {{{GraphScope Flex}}},
    author = {He, Tao and Hu, Shuxian and Lai, Longbin and Li, Dongze and Li,
              Neng and Li, Xue and Liu, Lexiao and Luo, Xiaojian and Lyu, Binqing
              and Meng, Ke and Shen, Sijie and Su, Li and Wang, Lei and Xu,
              Jingbo and Yu, Wenyuan and Zeng, Weibin and Zhang, Lei and Zhang,
              Siyuan and Zhou, Jingren and Zhou, Xiaoli and Zhu, Diwen},
    year = {2023},
    month = dec,
    number = {arXiv:2312.12107},
    eprint = {2312.12107},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2312.12107},
    urldate = {2025-04-30},
    abstract = {Graph computing has become increasingly crucial in processing
                large-scale graph data, with numerous systems developed for this
                purpose. Two years ago, we introduced GraphScope as a system
                addressing a wide array of graph computing needs, including graph
                traversal, analytics, and learning in one system. Since its
                inception, GraphScope has achieved significant technological
                advancements and gained widespread adoption across various
                industries. However, one key lesson from this journey has been
                understanding the limitations of a ``one-size-fits-all'' approach
                , especially when dealing with the diversity of programming
                interfaces, applications, and data storage formats in graph
                computing. In response to these challenges, we present GraphScope
                Flex, the next iteration of GraphScope. GraphScope Flex is
                designed to be both resource-efficient and cost-effective, while
                also providing flexibility and user-friendliness through its
                LEGO-like modularity. This paper explores the architectural
                innovations and fundamental design principles of GraphScope Flex,
                all of which are direct outcomes of the lessons learned during
                our ongoing development process. We validate the adaptability and
                efficiency of GraphScope Flex with extensive evaluations on
                synthetic and real-world datasets. The results show that
                GraphScope Flex achieves 2.4{\texttimes} throughput and up to
                55.7{\texttimes} speedup over other systems on the LDBC Social
                Network and Graphalytics benchmarks, respectively. Furthermore,
                GraphScope Flex accomplishes up to a 2,400{\texttimes}
                performance gain in real-world applications, demonstrating its
                proficiency across a wide range of graph computing scenarios with
                increased effectiveness.},
    archiveprefix = {arXiv},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/RN4MYZBV/He_Hu_2023_GraphScope_Flex_LEGO_lik.pdf
            },
}

@misc{howard2024RDFVsProperty,
    title = {{{RDF}} vs. {{Property Graphs}}: {{Choosing}} the {{Right Approach}
             } for {{Implementing}} a {{Knowledge Graph}}},
    shorttitle = {{{RDF}} vs. {{Property Graphs}}},
    author = {Howard, Rachel},
    year = {2024},
    month = jun,
    journal = {Graph Database \& Analytics},
    urldate = {2025-04-30},
    abstract = {Learn the ins and outs of RDF vs. property graphs so you can
                choose the right technology for building your knowledge graph.},
    howpublished = {
                    https://neo4j.com/blog/knowledge-graph/rdf-vs-property-graphs-knowledge-graphs/
                    },
    langid = {english},
}

@article{huang2011ScalableSPARQLQuerying,
    title = {Scalable {{SPARQL Querying}} of {{Large RDF Graphs}}},
    author = {Huang, Jiewen and Abadi, Daniel J and Ren, Kun},
    year = {2011},
    abstract = {The generation of RDF data has accelerated to the point where
                many data sets need to be partitioned across multiple machines in
                order to achieve reasonable performance when querying the data.
                Although tremendous progress has been made in the Semantic Web
                community for achieving high performance data management on a
                single node, current solutions that allow the data to be
                partitioned across multiple machines are highly inefficient. In
                this paper, we introduce a scalable RDF data management system
                that is up to three orders of magnitude more efficient than
                popular multi-node RDF data management systems. In so doing, we
                introduce techniques for (1) leveraging state-of-the-art single
                node RDF-store technology (2) partitioning the data across nodes
                in a manner that helps accelerate query processing through
                locality optimizations and (3) decomposing SPARQL queries into
                high performance fragments that take advantage of how data is
                partitioned in a cluster.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/PDWFLTV6/Huang_Abadi_Scalable_SPARQL_Querying.pdf
            },
}

@article{huang2020GQARDFEfficientSPARQL,
    title = {{{GQARDF}}: {{An Efficient SPARQL Query Answering Engine}} on {{RDF
             Graphs}}},
    author = {Huang, Chu and Zhang, Qianzhen and Guo, Deke and Zhao, Xiang and
              Wang, Xi},
    year = {2020},
    abstract = {Due to the increasing use of RDF data, efficient processing of
                SPARQL queries over RDF datasets has become an important issue.
                In graph-based RDF data management solution, SPARQL queries are
                translated into subgraph patterns and evaluated over RDF graphs
                via graph matching. However, answering SPARQL queries requires
                handing RDF reasoning to model implicit triples in RDF data,
                which is largely overlooked by existing graph-based solutions. In
                this paper, we investigate to equip graph-based solution with the
                important RDF reasoning feature for supporting SPARQL query
                answering. In detail, we first propose an ondemand saturation
                strategy, which only selects an RDF fragment that may be
                potentially affected by the query. Then, we provide a
                filtering-and-verification framework to efficiently compute the
                answers of a given query. The framework groups the equivalent
                entity vertices in the RDF graph to form semantic abstracted
                graph as index, and further computes the matches according to the
                multi-grade pruning supported by the index. In order to drive and
                expedite query evaluation, we conceive an effective cost model
                for estimating the step-wise cost of query pattern matching. In
                addition, we show that the semantic abstracted graph and the
                graph saturation can be efficiently updated upon the changes to
                the data graph, enabling the framework to cope with dynamic RDF
                graphs. The results of extensive experiments on real-life and
                synthetic datasets demonstrate the effectiveness and efficiency
                of our algorithms.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/BRMERCKA/Huang_Zhang_GQARDF_An_Efﬁcient_SPARQ.pdf
            },
}

@misc{inc2023FactorizationGreatIdeas,
    title = {Factorization and Great Ideas from Database Theory},
    author = {Inc, K{\`u}zu},
    year = {2023},
    month = jan,
    urldate = {2025-04-30},
    abstract = {Factorization and great ideas from database theory},
    howpublished = {https://blog.kuzudb.com/post/factorization/},
    langid = {english},
}

@misc{inc2023WhyGraphDBMSs,
    title = {Why ({{Graph}}) {{DBMSs Need New Join Algorithms}}},
    author = {Inc, K{\`u}zu},
    year = {2023},
    month = feb,
    urldate = {2025-04-30},
    abstract = {Why (Graph) DBMSs Need New Join Algorithms: The Story of
                Worst-case Optimal Join Algorithms},
    howpublished = {https://blog.kuzudb.com/post/wcoj/},
    langid = {english},
}

@misc{IntroductionCypherManual,
    title = {Introduction - {{Cypher Manual}}},
    journal = {Neo4j Graph Data Platform},
    urldate = {2025-05-10},
    abstract = {This section provides an introduction to the Cypher query
                language.},
    howpublished = {https://neo4j.com/docs/cypher-manual/5/introduction/},
    langid = {english},
    file = {/home/calle/Zotero/storage/2BHT5Z9J/introduction.html},
}

@misc{ISOIECGQL,
    title = {{{ISO}}/{{IEC GQL}}},
    shorttitle = {{{ISO}}/{{IEC GQL}}},
    journal = {ISO},
    urldate = {2025-05-10},
    abstract = {Information technology --- Database languages --- GQL},
    howpublished = {https://www.iso.org/standard/76120.html},
    langid = {english},
    file = {/home/calle/Zotero/storage/N65TJ5QR/76120.html},
}

@misc{ISOIECSQL,
    title = {{{ISO}}/{{IEC SQL}}/{{PGQ}}},
    shorttitle = {{{ISO}}/{{IEC SQL}}/{{PGQ}}},
    journal = {ISO},
    urldate = {2025-05-10},
    abstract = {Information technology --- Database languages SQL --- Part 16:
                Property Graph Queries (SQL/PGQ)},
    howpublished = {https://www.iso.org/standard/79473.html},
    langid = {english},
    file = {/home/calle/Zotero/storage/IPHCH2WF/79473.html},
}

@article{jinMakingRDBMSsEfficient2022,
    title = {Making {{RDBMSs}} Efficient on Graph Workloads through Predefined
             Joins},
    author = {Jin, Guodong and Salihoglu, Semih},
    year = {2022},
    month = jan,
    journal = {Proc. VLDB Endow.},
    volume = {15},
    number = {5},
    pages = {1011--1023},
    issn = {2150-8097},
    doi = {10.14778/3510397.3510400},
    urldate = {2024-11-18},
    abstract = {Joins in native graph database management systems (GDBMSs) are
                predefined to the system as edges, which are indexed in adjacency
                list indices and serve as pointers. This contrasts with and can
                be more performant than value-based joins in RDBMSs. Existing
                approaches to integrate predefined joins into RDBMSs adopt a
                strict separation of graph and relational data and processors,
                where a graph-specific processor uses left-deep and index nested
                loop joins (INLJ) for a subset of joins. In this paper we study
                and experimentally evaluate this technique's performance against
                an alternative technique that is based on using hash joins that
                use system-level row IDs (RIDs). In this alternative approach,
                when a join between two tables is predefined to the system, the
                RIDs of joining tuples are materialized in extended tables and
                optionally in RID indices. Instead of using the RID index to
                perform the join directly, we use it primarily in hash joins to
                generate filters that can be passed to scans using sideways
                information passing (sip), ensuring sequential scans. We further
                compare these two approaches against: (i) the default value-based
                joins of an RDBMS; and (ii) using materialized views that can
                avoid evaluating predefined joins completely and instead replace
                them with scans. We integrated our alternative approach to DuckDB
                and call the resulting system GRainDB. Our evaluation
                demonstrates that existing INJL-based approach can be very
                efficient when entity relations contain very selective filters.
                However, GRainDB's approach is more robust and is either
                competitive with or outperforms the INLJ-based approach across a
                wide range of settings. We further demonstrate that GRainDB far
                improves the performance of DuckDB, which uses default
                value-based joins, on relational and graph workloads with large
                many-to-many joins, making it competitive with a state-of-the-art
                GDBMS, and incurs no major overheads otherwise.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/V7UY88QB/Jin_Salihoglu_2022_Making_RDBMSs_efficient_o.pdf
            },
}

@article{khanKnowledgeGraphsQuerying,
    title = {Knowledge {{Graphs Querying}}},
    author = {Khan, Arijit},
    abstract = {Knowledge graphs (KGs) such as DBpedia, Freebase, YAGO, Wikidata
                , and NELL were constructed to store large-scale, real-world
                facts as hsubject, predicate, objecti triples -- that can also be
                modeled as a graph, where a node (a subject or an object)
                represents an entity with attributes, and a directed edge (a
                predicate) is a relationship between two entities. Querying KGs
                is critical in web search, question answering (QA), semantic
                search, personal assistants, fact checking, and recommendation.
                While significant progress has been made on KG construction and
                curation, thanks to deep learning recently we have seen a surge
                of research on KG querying and QA. The objectives of our survey
                are two-fold. First, research on KG querying has been conducted
                by several communities, such as databases, data mining, semantic
                web, machine learning, information retrieval, and natural
                language processing (NLP), with different focus and
                terminologies; and also in diverse topics ranging from graph
                databases, query languages, join algorithms, graph patterns
                matching, to more sophisticated KG embedding and natural language
                questions (NLQs). We aim at uniting different interdisciplinary
                topics and concepts that have been developed for KG querying.
                Second, many recent advances on KG and query embedding,
                multimodal KG, and KG-QA come from deep learning, IR, NLP, and
                computer vision domains. We identify important challenges of KG
                querying that received less attention by graph databases, and by
                the DB community in general, e.g., incomplete KG, semantic
                matching, multimodal data, and NLQs. We conclude by discussing
                interesting opportunities for the data management community, for
                instance, KG as a unified data model and vector-based query
                processing.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/D5MJIITC/Khan_Knowledge_Graphs_Querying.pdf
            },
}

@misc{KnowledgeGraphsRDF,
    title = {Knowledge {{Graphs}}: {{RDF}} or {{Property Graphs}}, {{Which One
             Should You Pick}}? -- {{Wisecube AI}} -- {{Research Intelligence
             Platform}}},
    shorttitle = {Knowledge {{Graphs}}},
    urldate = {2025-04-30},
    langid = {american},
}

@article{kostylevSPARQLPropertyPaths,
    title = {{{SPARQL}} with {{Property Paths}}},
    author = {Kostylev, Egor V and Reutter, Juan L and Romero, Miguel and Vrgo{
              \textasciicaron}c, Domagoj},
    abstract = {The original SPARQL proposal was often criticized for its
                inability to navigate through the structure of RDF documents. For
                this reason property paths were introduced in SPARQL 1.1, but up
                to date there are no theoretical studies examining how their
                addition to the language affects main computational tasks such as
                query evaluation, query containment, and query subsumption. In
                this paper we tackle all of these problems and show that although
                the addition of property paths has no impact on query evaluation,
                they do make the containment and subsumption problems
                substantially more difficult.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/VWD94W5X/Kostylev_Reutter_SPARQL_with_Property_Path.pdf
            },
}

@article{liu2020LargescaleGraphProcessing,
    title = {Large-Scale Graph Processing Systems: A Survey},
    shorttitle = {Large-Scale Graph Processing Systems},
    author = {Liu, Ning and Li, Dong-sheng and Zhang, Yi-ming and Li, Xiong-lve},
    year = {2020},
    month = mar,
    journal = {Front Inform Technol Electron Eng},
    volume = {21},
    number = {3},
    pages = {384--404},
    issn = {2095-9184, 2095-9230},
    doi = {10.1631/FITEE.1900127},
    urldate = {2025-04-22},
    langid = {english},
    keywords = {Done},
    file = {
            /home/calle/Zotero/storage/SDP4MREW/Liu_Li_2020_Large_scale_graph_process.pdf
            },
}

@misc{liu2025TigerVectorSupportingVector,
    title = {{{TigerVector}}: {{Supporting Vector Search}} in {{Graph Databases}
             } for {{Advanced RAGs}}},
    shorttitle = {{{TigerVector}}},
    author = {Liu, Shige and Zeng, Zhifang and Chen, Li and Ainihaer, Adil and
              Ramasami, Arun and Chen, Songting and Xu, Yu and Wu, Mingxi and
              Wang, Jianguo},
    year = {2025},
    month = apr,
    number = {arXiv:2501.11216},
    eprint = {2501.11216},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2501.11216},
    urldate = {2025-04-30},
    abstract = {In this paper, we introduce TigerVector, a system that
                integrates vector search and graph query within TigerGraph, a
                Massively Parallel Processing (MPP) native graph database. We
                extend the vertex attribute type with the embedding type. To
                support fast vector search, we devise an MPP index framework that
                interoperates efficiently with the graph engine. The graph query
                language GSQL is enhanced to support vector type expressions and
                enable query compositions between vector search results and graph
                query blocks. These advancements elevate the expressive power and
                analytical capabilities of graph databases, enabling seamless
                fusion of unstructured and structured data in ways previously
                unattainable. Through extensive experiments, we demonstrate
                TigerVector's hybrid search capability, scalability, and superior
                performance compared to other graph databases (including Neo4j
                and Amazon Neptune) and a highly optimized specialized vector
                database (Milvus). TigerVector was integrated into TigerGraph
                v4.2, the latest release of TigerGraph, in December 2024.},
    archiveprefix = {arXiv},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/4LCKMEZ4/Liu_Zeng_2025_TigerVector_Supporting_V.pdf
            },
}

@misc{LPGVsRDF,
    title = {{{LPG}} vs. {{RDF}}},
    journal = {Memgraph documentation},
    urldate = {2025-04-30},
    abstract = {Learn about different use cases and unique strengths of Labeled
                Property Graphs (LPG)~and~Resource Description Framework (RDF)~
                models.},
    howpublished = {
                    https://memgraph.com/docs/data-modeling/graph-data-model/lpg-vs-rdf
                    },
}

@misc{meckler2024ProcedureModelBuilding,
    title = {Procedure {{Model}} for {{Building Knowledge Graphs}} for {{
             Industry Applications}}},
    author = {Meckler, Sascha},
    year = {2024},
    publisher = {arXiv},
    doi = {10.48550/ARXIV.2409.13425},
    urldate = {2025-05-10},
    abstract = {Enterprise knowledge graphs combine business data and
                organizational knowledge by means of a semantic network of
                concepts, properties, individuals and relationships. The
                graph-based integration of previously unconnected information
                with domain knowledge provides new insights and enables
                intelligent business applications. However, knowledge graph
                construction is a large investment which requires a joint effort
                of domain and technical experts. This paper presents a practical
                step-by-step procedure model for building an RDF knowledge graph
                that interconnects heterogeneous data and expert knowledge for an
                industry use case. The self-contained process adapts the "Cross
                Industry Standard Process for Data Mining" and uses competency
                questions throughout the entire development cycle. The procedure
                model starts with business and data understanding, describes
                tasks for ontology modeling and the graph setup, and ends with
                process steps for evaluation and deployment.},
    copyright = {Creative Commons Attribution Non Commercial Share Alike 4.0
                 International},
    file = {
            /home/calle/Zotero/storage/QNMRMXSZ/Meckler_2024_Procedure_Model_for_Build.pdf
            },
}

@misc{Memgraph,
    title = {Memgraph},
    urldate = {2025-05-10},
    abstract = {Experience high-performance graph computing with Memgraph ---
                the scalable, in-memory graph database solution compatible with
                Neo4j.},
    howpublished = {https://memgraph.com/},
    langid = {english},
    file = {/home/calle/Zotero/storage/I544B9RK/memgraph.com.html},
}

@article{mhedhbiOptimizingOnetimeContinuous,
    title = {Optimizing {{One-time}} and {{Continuous Subgraph Queries}} Using {
             {Worst-case Optimal Joins}}},
    author = {Mhedhbi, Amine and Kankanamge, Chathura and Salihoglu, Semih},
    journal = {ACM Transactions on Database Systems},
    volume = {46},
    number = {2},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/MAAFAU5X/Mhedhbi_Kankanamge_Optimizing_One_time_and_C.pdf
            },
}

@article{mhedhbiOptimizingSubgraphQueries2019,
    title = {Optimizing Subgraph Queries by Combining Binary and Worst-Case
             Optimal Joins},
    author = {Mhedhbi, Amine and Salihoglu, Semih},
    year = {2019},
    month = jul,
    journal = {Proc. VLDB Endow.},
    volume = {12},
    number = {11},
    pages = {1692--1704},
    issn = {2150-8097},
    doi = {10.14778/3342263.3342643},
    urldate = {2024-11-18},
    abstract = {We study the problem of optimizing subgraph queries using the
                new worst-case optimal join plans. Worst-case optimal plans
                evaluate queries by matching one query vertex at a time using
                multiway intersections. The core problem in optimizing worst-case
                optimal plans is to pick an ordering of the query vertices to
                match. We design a cost-based optimizer that (i) picks efficient
                query vertex orderings for worst-case optimal plans; and (ii)
                generates hybrid plans that mix traditional binary joins with
                worst-case optimal style multiway intersections. Our cost metric
                combines the cost of binary joins with a new cost metric called
                intersection-cost. The plan space of our optimizer contains plans
                that are not in the plan spaces based on tree decompositions from
                prior work. In addition to our optimizer, we describe an adaptive
                technique that changes the orderings of the worst-case optimal
                subplans during query execution. We demonstrate the effectiveness
                of the plans our optimizer picks and the effectiveness of the
                adaptive technique through extensive experiments. Our optimizer
                is integrated into the Graphflow DBMS.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/EKXI22D8/Mhedhbi_Salihoglu_2019_Optimizing_subgraph_queri.pdf
            },
}

@misc{mo2025AsterEnhancingLSMstructures,
    title = {Aster: {{Enhancing LSM-structures}} for {{Scalable Graph Database}}
             },
    shorttitle = {Aster},
    author = {Mo, Dingheng and Liu, Junfeng and Wang, Fan and Luo, Siqiang},
    year = {2025},
    month = jan,
    number = {arXiv:2501.06570},
    eprint = {2501.06570},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2501.06570},
    urldate = {2025-04-30},
    abstract = {There is a proliferation of applications requiring the
                management of large-scale, evolving graphs under workloads with
                intensive graph updates and lookups. Driven by this challenge, we
                introduce Poly-LSM, a high-performance key-value storage engine
                for graphs with the following novel techniques: (1) Poly-LSM is
                embedded with a new design of graph-oriented LSM-tree structure
                that features a hybrid storage model for concisely and
                effectively storing graph data. (2) Poly-LSM utilizes an adaptive
                mechanism to handle edge insertions and deletions on graphs with
                optimized I/O efficiency. (3) Poly-LSM exploits the skewness of
                graph data to encode the key-value entries. Building upon this
                foundation, we further implement Aster, a robust and versatile
                graph database that supports Gremlin query language facilitating
                various graph applications. In our experiments, we compared Aster
                against several mainstream real-world graph databases. The
                results demonstrate that Aster outperforms all baseline graph
                databases, especially on large-scale graphs. Notably, on the
                billion-scale Twitter graph dataset, Aster achieves up to 17x
                throughput improvement compared to the best-performing baseline
                graph system.},
    archiveprefix = {arXiv},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/G5XAS6TQ/Mo_Liu_2025_Aster_Enhancing_LSM_stru.pdf
            },
}

@article{mokhovLanguageHardwareAcceleration,
    title = {Language and Hardware Acceleration Backend for Graph Processing},
    author = {Mokhov, Andrey},
    abstract = {Graphs are important in many applications however their analysis
                on conventional computer architectures is generally inefficient
                because it involves highly irregular access to memory when
                traversing vertices and edges. As an example, when finding a path
                from a source vertex to a target one the performance is typically
                limited by the memory bottleneck whereas the actual computation
                is trivial.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/SAU3R48K/Mokhov_Language_and_hardware_acc.pdf
            },
}

@article{olteanuFactorizedDatabases2016,
    title = {Factorized {{Databases}}},
    author = {Olteanu, Dan and Schleich, Maximilian},
    year = {2016},
    month = sep,
    journal = {SIGMOD Rec.},
    volume = {45},
    number = {2},
    pages = {5--16},
    issn = {0163-5808},
    doi = {10.1145/3003665.3003667},
    urldate = {2025-03-19},
    abstract = {This paper overviews factorized databases and their application
                to machine learning. The key observation underlying this work is
                that state-of-the-art relational query processing entails a high
                degree of redundancy in the computation and representation of
                query results. This redundancy can be avoided and is not
                necessary for subsequent analytics such as learning regression
                models.},
    langid = {english},
    keywords = {Todo},
    file = {
            /home/calle/Zotero/storage/EM5QY4X7/Olteanu_Schleich_2016_Factorized_Databases.pdf
            },
}

@misc{OpenCypherOpenCypher,
    title = {{{openCypher}} {$\cdot$} {{openCypher}}},
    urldate = {2025-05-10},
    howpublished = {https://opencypher.org/},
    file = {/home/calle/Zotero/storage/338WV6B5/opencypher.org.html},
}

@misc{OWL2Web,
    title = {{{OWL}} 2 {{Web Ontology Language Primer}} ({{Second Edition}})},
    urldate = {2025-05-10},
    howpublished = {https://www.w3.org/TR/owl-primer/},
    file = {/home/calle/Zotero/storage/Q2JT3R37/owl-primer.html},
}

@misc{PageRankGraphData,
    title = {{{PageRank}} - {{Graph Data Science Library}}},
    journal = {TigerGraph Documentation},
    urldate = {2025-04-30},
    abstract = {The Only Scalable Platform for Analytics and ML on Connected
                Data},
    howpublished = {
                    https://docs.tigergraph.com/graph-ml/3.10/centrality-algorithms/pagerank
                    },
    langid = {english},
}

@misc{PathFindingNeo4j,
    title = {Path Finding - {{Neo4j Graph Data Science}}},
    journal = {Neo4j Graph Data Platform},
    urldate = {2025-04-30},
    abstract = {This chapter provides explanations and examples for each of the
                path finding algorithms in the Neo4j Graph Data Science library.},
    howpublished = {
                    https://neo4j.com/docs/graph-data-science/2.17/algorithms/pathfinding/
                    },
    langid = {english},
}

@misc{PGQLPropertyGraph,
    title = {{{PGQL}} {\textbar} {{Property Graph Query Language}}},
    urldate = {2025-04-29},
    howpublished = {https://pgql-lang.org/},
    file = {/home/calle/Zotero/storage/YFMELGAJ/pgql-lang.org.html},
}

@misc{RDF11Concepts,
    title = {{{RDF}} 1.1 {{Concepts}} and {{Abstract Syntax}}},
    urldate = {2025-05-11},
    howpublished = {https://www.w3.org/TR/rdf11-concepts/},
    file = {/home/calle/Zotero/storage/W52LPZF2/rdf11-concepts.html},
}

@misc{RDF11Semantics,
    title = {{{RDF}} 1.1 {{Semantics}}},
    urldate = {2025-05-10},
    howpublished = {https://www.w3.org/TR/rdf11-mt/},
    file = {/home/calle/Zotero/storage/FG3UXQHJ/rdf11-mt.html},
}

@misc{RDFSchema11,
    title = {{{RDF Schema}} 1.1},
    urldate = {2025-05-10},
    howpublished = {https://www.w3.org/TR/rdf-schema/},
    file = {/home/calle/Zotero/storage/9ISSNAFP/rdf-schema.html},
}

@misc{RDFSemanticWeb,
    title = {{{RDF}} - {{Semantic Web Standards}}},
    urldate = {2025-05-11},
    howpublished = {https://www.w3.org/RDF/},
    file = {/home/calle/Zotero/storage/FLVD2QQM/RDF.html},
}

@book{robinson2015GraphDatabasesNew,
    title = {Graph Databases [New Opportunities for Connected Data]},
    author = {Robinson, Ian and Webber, Jim and Eifrem, Emil},
    year = {2015},
    edition = {2nd ed},
    publisher = {O'Reilly},
    address = {Sebastopol, CA},
    isbn = {978-1-4919-3200-1},
    langid = {english},
    annotation = {OCLC: 1028626678},
    file = {
            /home/calle/Zotero/storage/V4VV5LUN/Robinson_Webber_2015_Graph_databases_[new_oppo.pdf
            },
}

@misc{shimizu2024KnowWhereGraphOntology,
    title = {The {{KnowWhereGraph Ontology}}},
    author = {Shimizu, Cogan and Stephe, Shirly and Barua, Adrita and Cai, Ling
              and Christou, Antrea and Currier, Kitty and Dalal, Abhilekha and
              Fisher, Colby K. and Hitzler, Pascal and Janowicz, Krzysztof and Li
              , Wenwen and Liu, Zilong and Mahdavinejad, Mohammad Saeid and Mai,
              Gengchen and Rehberger, Dean and Schildhauer, Mark and Shi, Meilin
              and Norouzi, Sanaz Saki and Tian, Yuanyuan and Wang, Sizhe and Wang
              , Zhangyu and Zalewski, Joseph and Zhou, Lu and Zhu, Rui},
    year = {2024},
    month = oct,
    number = {arXiv:2410.13948},
    eprint = {2410.13948},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2410.13948},
    urldate = {2025-05-11},
    abstract = {KnowWhereGraph is one of the largest fully publicly available
                geospatial knowledge graphs. It includes data from 30 layers on
                natural hazards (e.g., hurricanes, wildfires), climate variables
                (e.g., air temperature, precipitation), soil properties, crop and
                land-cover types, demographics, and human health, various place
                and region identifiers, among other themes. These have been
                leveraged through the graph by a variety of applications to
                address challenges in food security and agricultural supply
                chains; sustainability related to soil conservation practices and
                farm labor; and delivery of emergency humanitarian aid following
                a disaster. In this paper, we introduce the ontology that acts as
                the schema for KnowWhereGraph. This broad overview provides
                insight into the requirements and design specifications for the
                graph and its schema, including the development methodology
                (modular ontology modeling) and the resources utilized to
                implement, materialize, and deploy KnowWhereGraph with its
                end-user interfaces and public query SPARQL endpoint.},
    archiveprefix = {arXiv},
    langid = {english},
    keywords = {Computer Science - Artificial Intelligence},
    file = {
            /home/calle/Zotero/storage/WG8ZF6NW/Shimizu_Stephe_2024_The_KnowWhereGraph_Ontolo.pdf
            },
}

@misc{SPARQL11Property,
    title = {{{SPARQL}} 1.1 {{Property Paths}}},
    urldate = {2025-05-10},
    howpublished = {https://www.w3.org/TR/sparql11-property-paths/},
    file = {/home/calle/Zotero/storage/CJ228CT7/sparql11-property-paths.html},
}

@misc{SPARQL11Query,
    title = {{{SPARQL}} 1.1 {{Query Language}}},
    urldate = {2025-04-23},
    howpublished = {https://www.w3.org/TR/sparql11-query/},
    file = {/home/calle/Zotero/storage/ADPHRQCB/sparql11-query.html},
}

@misc{SPARQL12Query,
    title = {{{SPARQL}} 1.2 {{Query Language}}},
    urldate = {2025-04-23},
    howpublished = {https://www.w3.org/TR/sparql12-query/},
    file = {/home/calle/Zotero/storage/7PG6DVFC/sparql12-query.html},
}

@misc{theodorakis2024AionEfficientTemporal,
    title = {Aion: {{Efficient Temporal Graph Data Management}}},
    shorttitle = {Aion},
    author = {Theodorakis, Georgios and Clarkson, James and Webber, Jim},
    year = {2024},
    publisher = {OpenProceedings.org},
    doi = {10.48786/EDBT.2024.43},
    urldate = {2025-04-30},
    abstract = {Modern graph database management systems (DBMSs) can process
                highly dynamic labeled property graphs (LPGs) with many billions
                of relationships comfortably, but those systems often ignore the
                temporal dimension of data, how a graph evolved over time.
                Temporal analytics allow users to query and compute over the
                graph throughout its history so that valuable line-of-business
                data is always accessible and never lost. However, existing
                approaches tend to be ad-hoc and vary in performance depending on
                the size of the effective graph workload, such as local pattern
                matching or global graph algorithms.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/8GCSN3TJ/Theodorakis_Clarkson_2024_Aion_Efficient_Temporal.pdf
            },
}

@misc{TinkerPopDocumentation,
    title = {{{TinkerPop Documentation}}},
    urldate = {2025-05-10},
    howpublished = {https://tinkerpop.apache.org/docs/current/reference/},
    file = {/home/calle/Zotero/storage/TZWS9FYH/reference.html},
}

@article{trarisWherePathLeads,
    title = {Where the {{Path Leads}}: {{State}} of the {{Art}} and {{Challenges
             }} of {{Graph Database Systems}}},
    author = {Traris, Tim and Balsacq, Maxim},
    abstract = {Compared to relational databases, graph database systems provide
                a novel way of processing and analyzing highly interconnected
                data. Due to their unique properties, graph databases embody an
                interesting area of research in academic circles. For this reason
                , this work is fundamentally concerned with examining the state
                of the industry and current challenges. In this regard, we
                revisit the basic concepts and highlight the tremendous
                heterogeneity of available systems using the example of differing
                path semantics. Based on this insight, we explore algorithmic
                advancements for graph query processing regarding path finding
                and worst-case optimal joins. Subsequently, we discuss issues
                regarding performance and support for graph analytics. Finally,
                we provide an overview of GQL, a joint standardization effort
                towards unification of property graph databases.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/DGAQZBHS/Traris_Balsacq_Where_the_Path_Leads_Sta.pdf
            },
}

@misc{VariablelengthPatternsCypher,
    title = {Variable-Length Patterns - {{Cypher Manual}}},
    journal = {Neo4j Graph Data Platform},
    urldate = {2025-05-11},
    abstract = {Information about quantified path patterns, quantified
                relationships, and group variables.},
    howpublished = {
                    https://neo4j.com/docs/cypher-manual/5/patterns/variable-length-patterns/
                    },
    langid = {english},
    file = {/home/calle/Zotero/storage/NSQJ6F8F/variable-length-patterns.html},
}

@article{warnkeUsingMachineLearning,
    title = {Using {{Machine Learning}} and {{Routing Protocols}} for {{
             Optimizing Distributed SPARQL Queries}} in {{Collaboration}}},
    author = {Warnke, Benjamin and Fischer, Stefan and Groppe, Sven},
    abstract = {Due to increasing digitization, the amount of data in the
                Internet of Things (IoT) is constantly increasing. In order to be
                able to process queries efficiently, strategies must, therefore,
                be found to reduce the transmitted data as much as possible.
                SPARQL is particularly well-suited to the IoT environment because
                it can handle various data structures. Due to the flexibility of
                data structures, however, more data have to be joined again
                during processing. Therefore, a good join order is crucial as it
                significantly impacts the number of intermediate results. However
                , computing the best linking order is an NP-hard problem because
                the total number of possible linking orders increases
                exponentially with the number of inputs to be combined. In
                addition, there are different definitions of optimal join orders.
                Machine learning uses stochastic methods to achieve good results
                even with complex problems quickly. Other DBMSs also consider
                reducing network traffic but neglect the network topology.
                Network topology is crucial in IoT as devices are not evenly
                distributed. Therefore, we present new techniques for
                collaboration between routing, application, and machine learning.
                Our approach, which pushes the operators as close as possible to
                the data source, minimizes the produced network traffic by 10\%.
                Additionally, the model can reduce the number of intermediate
                results by a factor of 100 in comparison to other
                state-of-the-art approaches.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/TZ8795VM/Warnke_Fischer_Using_Machine_Learning_an.pdf
            },
}

@article{woodQueryLanguagesGraph,
    title = {Query {{Languages}} for {{Graph Databases}}},
    author = {Wood, Peter T},
    abstract = {Query languages for graph databases started to be investigated
                some 25 years ago. With much current data, such as linked data on
                the Web and social network data, being graph-structured, there
                has been a recent resurgence in interest in graph query
                languages. We provide a brief survey of many of the graph query
                languages that have been proposed, focussing on the core
                functionality provided in these languages. We also consider
                issues such as expressive power and the computational complexity
                of query evaluation.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/YZJPBLQR/Wood_Query_Languages_for_Graph.pdf
            },
}

@misc{zhang2024GraphitronDomainSpecific,
    title = {Graphitron: {{A Domain Specific Language}} for {{FPGA-based Graph
             Processing Accelerator Generation}}},
    shorttitle = {Graphitron},
    author = {Zhang, Xinmiao and Feng, Zheng and Liang, Shengwen and Chen, Xinyu
              and Liu, Cheng and Li, Huawei and Li, Xiaowei},
    year = {2024},
    month = jul,
    number = {arXiv:2407.12575},
    eprint = {2407.12575},
    primaryclass = {cs},
    publisher = {arXiv},
    doi = {10.48550/arXiv.2407.12575},
    urldate = {2025-04-30},
    abstract = {FPGA-based graph processing accelerators, enabling extensive
                customization, have demonstrated significant energy efficiency
                over general computing engines like CPUs and GPUs. Nonetheless,
                customizing accelerators to diverse graph processing algorithms
                with distinct computational patterns remains challenging and
                error-prone for high-level application users. To this end,
                template-based approaches following established graph processing
                frameworks have been developed to automate the graph processing
                accelerator generation. Although these frameworks significantly
                enhance the design productivity, the templates often result in
                closely coupled algorithms, programming models, and architectures
                , severely limiting the versatility of the targeted graph
                processing algorithms and their applicability to high-level
                users. Furthermore, the limitations of the frameworks are usually
                ambiguous due to the absence of a rigorous grammar definition.},
    archiveprefix = {arXiv},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/LIUG6HHK/Zhang_Feng_2024_Graphitron_A_Domain_Spec.pdf
            },
}

@article{zhouDesignImplementationParallel,
    title = {Design and {{Implementation}} of {{Parallel PageRank}} on {{
             Multicore Platforms}}},
    author = {Zhou, Shijie and Lakhotia, Kartik and Singapura, Shreyas G and
              Zeng, Hanqing and Kannan, Rajgopal and Prasanna, Viktor K and Fox,
              James and Kim, Euna and Green, Oded and Bader, David A},
    abstract = {PageRank is a fundamental graph algorithm to evaluate the
                importance of vertices in a graph. In this paper, we present an
                efficient parallel PageRank design based on an edge-centric
                scatter-gather model. To overcome the poor locality of PageRank
                and optimize the memory performance, we develop a fast and
                efficient partitioning technique. We first partition all the
                vertices into non-overlapping vertex sets such that the data of
                each vertex set can fit in the cache; then we sort the outgoing
                edges of each vertex set based on the destination vertices to
                minimize random memory writes. The partitioning technique
                significantly reduces random accesses to main memory and improves
                the sustained memory bandwidth by 3{\texttimes}. It also enables
                efficient parallel execution on multicore platforms; we use
                distinct cores to execute the computations of distinct vertex
                sets in parallel to achieve speedup. We implement our design on a
                16-core Intel Xeon processor and use various large-scale
                real-life and synthetic datasets for evaluation. Compared with
                the PageRank Pipeline Benchmark, our design achieves 12{
                \texttimes} to 19{\texttimes} speedup for all the datasets.},
    langid = {english},
    file = {
            /home/calle/Zotero/storage/KF7M6N3S/Zhou_Lakhotia_Design_and_Implementation.pdf
            },
}
